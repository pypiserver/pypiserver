# Workflow management for new tag releases.
#   Inspired on the Python packaging guide.
#     https://packaging.python.org/en/latest/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows/
name: Publish new pypiserver release

on:
  push:
    tags:
      - v*

jobs:

  ########
  # PYPI #
  ########

  build_wheel_and_push_to_pypi:
    runs-on: ubuntu-latest
    steps:
      - name: Wait for tests to succeed
        uses: lewagon/wait-on-check-action@v1.0.0
        with:
          ref: ${{ github.ref }}
          check-name: 'tests'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10

      - uses: actions/checkout@master
      - name: Set up Python 3.8
        uses: actions/setup-python@v1
        with:
          python-version: 3.8

      - name: Build distribution _wheel_.
        run: |
          /bin/package.sh

      - name: Publish distribution ðŸ“¦ to PyPI.
        if: startsWith(github.ref, 'refs/tags')
        uses: pypa/gh-action-pypi-publish@master
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          print_hash: true

  ##########
  # Docker #
  ##########

  # figure out which docker tags we need to push
  docker-determine-tags:
    runs-on: "ubuntu-latest"
    steps:
      - name: Wait for tests to succeed
        uses: lewagon/wait-on-check-action@v1.0.0
        with:
          ref: ${{ github.ref }}
          check-name: 'tests'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10

      - uses: "actions/checkout@v2"

      - uses: "actions/setup-python@v2"
        with:
          python-version: "3.9"

        # This script prints a JSON array of needed docker tags, depending on the
        # ref. That array is then used to construct the matrix of the
        # deploy-docker job
      - name: "Get expected docker tags"
        id: "tags"
        run: >-
          echo "::set-output name=tags::$(bin/ci_helper.py ${{ github.ref }} docker_tags)"

        # This is needed because GH actions will fail on an empty matrix, so
        # we need to be sure the `if` condition is false on the next job if
        # the matrix will be empty. The script prints 'true' if the array is
        # not empty, or 'false' otherwise.
      - name: "Determine whether any tags are needed"
        id: "has_tags"
        run: >-
          echo "::set-output name=has_tags::$(bin/ci_helper.py ${{ github.ref }} has_tags)"

    outputs:
      tags: "${{ steps.tags.outputs.tags }}"
      has_tags: "${{ steps.has_tags.outputs.has_tags }}"

  # Deploy any needed docker tags
  deploy-docker:
    runs-on: "ubuntu-latest"
    needs:
      - "docker-determine-tags"
    if: "${{ fromJson(needs.docker-determine-tags.outputs.has_tags) }}"
    strategy:
      matrix:
        tag: "${{ fromJson(needs.docker-determine-tags.outputs.tags) }}"
    steps:
      - uses: "actions/checkout@v2"

      - name: "Cache Docker layers"
        uses: "actions/cache@v2"
        with:
          path: "/tmp/.buildx-cache"
          key: "${{ runner.os }}-buildx-${{ github.sha }}"
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: "Login to Docker Hub"
        uses: "docker/login-action@v1"
        with:
          username: "${{ secrets.DOCKER_HUB_USER }}"
          password: "${{ secrets.DOCKER_HUB_TOKEN }}"

      - name: "Set up Docker Buildx"
        id: "buildx"
        uses: "docker/setup-buildx-action@v1"

      - name: "Build and push"
        id: "docker_build"
        uses: "docker/build-push-action@v2"
        with:
          context: "./"
          file: "./Dockerfile"
          builder: "${{ steps.buildx.outputs.name }}"
          push: true
          tags:  "pypiserver/pypiserver:${{ matrix.tag }}"
          cache-from: "type=local,src=/tmp/.buildx-cache"
          cache-to: "type=local,dest=/tmp/.buildx-cache"

      - name: "Image digest"
        run: "echo ${{ steps.docker_build.outputs.digest }}"
